Метасимволы:

. (dot) - представляет собой любой символ. Важно отметить, что точка (.) соответствует только одному символу.
[] (символьный класс) - диапазон. Количество символов, которые вы можете поместить в квадратные скобки, не ограничено. Вы можете разместить один символ, например, [у] (это было бы немного глупо, но, тем не менее, это не нарушает правила) или вы можете указать несколько символов, например, [Grf4s2 # lknx].

Использование наборов символов иногда может привести к странному поведению. Например, вы можете использовать диапазон [a-f] и обнаружить, что ему соответствует символ D. Это связано с таблицами символов, которые использует система. В большинстве систем есть таблица символов, в которой сначала идут все строчные буквы, а затем все заглавные (например, abcdef...xyzABCD...). Однако некоторые системы чередуют строчные и прописные буквы (например, aAbBcCdD...yYzZ). Если вы столкнулись с каким-то странным поведением и при этом используете диапазоны, то это первое, что нужно проверить.

^ (циркумфлекс) - крышка. Понадобиться чтобы найти символ, который не входит в диапазон искомых. Мы можем это сделать, поместив знак вставки (^) в начало диапазона.

Любые символы, которые обычно имеют особое значение (метасимволы), теряют свое особое значение и становятся обычными символами, находясь внутри диапазона. Исключением является знак вставки (^), который приобретает новое значение — отрицание.

Есть некоторые диапазоны символов, которые используются очень часто, поэтому для них был создан набор метасимволов. Для доступа к ним используется бэкслеш \, за которым следует необходимая буква (в этом случае экранирующий символ вводит особое значение, а не убирает его).

   \s — соответствует всему, что считается пробелом (например: пробел, табуляция, разрыв строки и т.д.);

   \S — является противоположностью \s и соответствует любым символам, которые не являются пробелами;

   \d — соответствует любым цифрам от 0 до 9 (по сути, это сокращение для [0-9]);

   \D — является противоположностью \d и соответствует любым символам, которые не являются цифрами;

   \w — соответствует любому строковому символу: [A-Za-z0-9_]. Обратите внимание на символ подчеркивания (_), он часто используется в именах переменных/функций.

   \W — является противоположностью \w и соответствует любым символам, которые не являются строковыми символами.

Вы уже заметили, что в списке, приведенном выше, выполняемые действия для любой буквы, указанной в верхнем регистре, всегда являются противоположностью тому, что делается для этой же буквы в нижнем регистре?

Вышеприведенные сокращения соответствуют одному символу, но с помощью мультипликаторов мы можем увеличить количество соответствующих символов. Например, если мы хотим найти какие-либо суммы в долларах, содержащие 4 цифры, мы можем написать следующее регулярное выражение:

Регулярное выражение: \$\d{4}
Пример: Today I earned $58327 but lost $3826.

Обратите внимание, в этом примере я использовал бэкслеш для экранирования символа $. Этот символ имеет особое значение.

Мультипликаторы:
   * — значение встречается 0 или более раз;

   + — значение встречается 1 или более раз;

   ? — значение встречается 0 или 1 раз;

   {5} — значение встречается 5 раз;

   {3,7} — значение встречается от 3 до 7 раз;

   {2,} — значение встречается не менее 2 раз.
   
Их действие распространяется на всё, что находится прямо перед ними. Это может быть обычный символ, например lo*

l.*k
Пример: Are you looking at the lock or the silk?

На первый взгляд такой результат может показаться вам немного странным. Регулярное выражение .* соответствует повторению ноль или более раз любого символа. Вы могли бы подумать, что при нахождении первого k, будет сказано «да, я нашел совпадение», но на самом деле говорится, что «k является любым символом, поэтому давайте посмотрим, на сколько длинным может быть соответствие», и поиск продолжится, пока не будет найден последний k в строке.

Это то, что называется «жадным сопоставлением». Это нормальное поведение — пытаться найти самую большую строку, которая может соответствовать шаблону. Мы можем изменить это поведение и сделать его «нежадным», поместив вопросительный знак (?) после мультипликатора (что может показаться немного запутанным, поскольку вопросительный знак сам по себе является множителем):

Регулярное выражение: l.*?k
Пример: Are you looking at the lock or the silk?

Экранирование:

Регулярное выражение: this.
Пример: Surely this regular expression should match this.

То нашли бы this. как в конце предложения, так и в начале, потому что точка в регулярном выражении обычно соответствует любому символу.

Решением будет следующее:

Регулярное выражение: this\.
Пример: Surely this regular expression should match this.


Когда метасимволы являются частью вашей искомой строки, то очень легко забыть об их экранировании. Если в результатах ваших регулярных выражений что-то не так, то внимательно обследуйте метасимволы, которые вы, возможно, забыли экранировать.

Непечатаемые символы:

Помимо наших обычных символов, есть несколько других символов, которые мы не видим, но которые помогают нам в форматировании нашего текста:

   tab — представлен в регулярных выражениях как \t;

   возврат каретки — представлен в регулярных выражениях как \r;

   перевод строки (или «символ новой строки», «разрыв строки») — представлен в регулярных выражениях как \n.

Концепции символов возврата каретки и новой строки появились на механических пишущих машинках. Функция возврата каретки перемещает курсор из конца строки в её начало. Перевод строки означает перемещение курсора из текущей строки в новую.

В зависимости от используемой вами ОС, эти символы или их комбинации могут использоваться для обозначения новой строки:

   Windows — используется последовательность \r\n;

   Mac OS (версия 9 и ранее) — используется последовательность \r;

   Unix/Linux — используется последовательность \n.


\n и \r присутствуют в одних реализациях регулярных выражений, но отсутствуют в других. Если вы столкнулись с каким-то непонятным поведением регулярных выражений, то, возможно, причиной этому является нереализованность корректным образом этих сокращений в используемом вами инструменте.


Якоря:

При определении новых строк мы всегда можем ссылаться на 2 конкретных местоположения в строке — на начало и на конец строки:

   ^ (символ каретки) — представляет начало строки;

   $ (символ доллара) — представляет конец строки.

О строке, приведенной выше, люди обычно говорят, что буква «В» в слове «Важно» и точка в конце обозначают начало и конец строки. Это, на самом деле, не так (по отношению к регулярным выражениям). Начало строки — это символ нулевой ширины, который находится непосредственно перед «В», а конец строки — это символ нулевой ширины, который находится сразу после точки. Под «нулевой шириной» мы подразумеваем, что при написании эти символы не отображаются. Они есть, но мы не можем их видеть.

Эти две позиции в строке называются якорями, поскольку они позволяют нам привязать шаблон регулярного выражения к конкретной точке в строке.

Допустим, мы хотим найти число, но при условии, что оно является первым элементом строки:

Регулярное выражение: ^\d+
Пример: 13 cats escaped from the 5 cages at the vet's clinic.

Совместное использование символов начала и конца строки может быть использовано для поиска чего-то уникального в строке. Например, мы хотим найти строки, содержащие только одно слово, которое может быть либо bat, либо bit, либо but:

Регулярное выражение: ^b[aiu]t$
Пример (строка №1): This line does not match but the next line does.
Пример (строка №2): bat

Границы слова:

Границы слова являются примером другого символа нулевой ширины, часто используемого в регулярных выражениях. Граница слова — это начало или конец слова. Оно может быть идентифицировано с использованием следующего:

   \< — представляет начало слова;

   \> — представляет конец слова;

   \b — представляет либо начало, либо конец слова.

Первые два элемента, перечисленные выше, доступны не во всех инструментах регулярных выражений, но \b, как правило, более распространено в использовании.

Слово — это строка, которая состоит из символов, которые включают в себя \w (т.е. A-Z, a-z, 0-9 и _). Обратите внимание, знаки препинания, такие как апостроф ('), не входят в это определение.

Регулярное выражение: \bt\w+\b
Пример: Now that's the truth and you know it.


Группирование:

Мы можем сгруппировать несколько символов в нашем регулярном выражении, используя круглые скобки (). Затем мы можем выполнить разные действия с этой группой символов (например, добавить мультипликаторы).

Допустим, нам нужно узнать, упоминается ли какой-то конкретный человек. Его могут звать John Reginald Smith, но второе имя может присутствовать, а может и нет:

Регулярное выражение: John (Reginald )?Smith
Пример: John Reginald Smith is sometime just called John Smith.


Обратите внимание на пробелы в регулярном выражении, приведенном выше. Важно помнить, что они являются частью вашего регулярного выражения, и вы должны убедиться, что они находятся в нужных местах.

Регулярное выражение: John (Reginald)? Smith
Пример: Проблема с этим регулярным выражением заключается в том, что оно найдет соответствие John Reginald Smith и даже John  Smith (два пробела между John и Smith), но не найдет соответствие John Smith. Можете ли вы понять, почему?

Вы не ограничены только обычными символами в скобках. Вы можете использовать в скобках и метасимволы (включая мультипликаторы).

Например, нам нужно найти экземпляры IP-адресов. IP-адрес представляет собой набор из 4 чисел (от 0 до 255), разделенных точками (например, 192.168.0.5):

Регулярное выражение: \b(\d{1,3}\.){3}\d{1,3}\b
Пример: The server has an address of 10.18.0.20 and the printer has an address of 10.18.0.116.

Это уже немного сложнее, поэтому давайте разберемся детально:

   \b обозначает границу слова;

   здесь мы разбили IP-адрес на 3 части, состоящие из чисел от 0 до 255 + точки + последнее (4-е) число от 0 до 255;

   в скобках мы обрабатываем первые 3 части IP-адреса: \d{1,3} указывает на то, что мы ищем от 1 до 3 цифр + точку, следующую за этими цифрами, которую мы не забываем экранировать (\.). Мы ищем ровно 3 таких последовательности, поэтому указываем мультипликатор {3} сразу за скобками;

   наконец, мы ищем 4-е число, указывая \d{1,3}, и обозначаем конечную границу слова (\b).


Обратные ссылки:

Всякий раз, когда мы сопоставляем что-либо в круглых скобках, это значение фактически сохраняется в переменной, к которой мы можем обратиться позже в регулярном выражении. Для доступа к этой переменной мы используем escape-символ (\), за которым следует цифра. Первый набор скобок обозначается как \1, второй — \2 и т.д.

Допустим, нам нужно найти строки с двумя упоминаниями о человеке с фамилией Smith. При этом, мы не знаем его имени. Мы могли бы сделать следующее:

Регулярное выражение: (\b[A-Z]\w+\b) Smith.*\1 Smith
Пример: Harold Smith went to meet John Smith but John Smith was not there.

В этом примере мы сопоставляем текст между двумя экземплярами Джона Смита, но в этом случае, это нормально, поскольку мы не слишком обеспокоены тем, что было сопоставлено, нам важно только наличие совпадения.


Чередование и оператор ИЛИ:

При чередовании мы имеем возможность искать что-либо из указанного нами списка. Мы видели очень простой пример чередования с использованием оператора диапазона. Это позволяет нам выполнить поиск одного символа, но иногда нам может быть нужно выполнить операцию и с большим набором символов. Это делается с помощью оператора ИЛИ (|). Например, нам нужно найти все экземпляры dog или cat:

Регулярное выражение: dog|cat
Пример: Harold Smith has two dogs and one cat.

Мы также можем использовать несколько операторов ИЛИ для нахождения большего количества вариантов:

Регулярное выражение: dog|cat|bird
Пример: Harold Smith has two dogs, one cat and three birds.

Иногда нам может быть нужно, чтобы чередование происходило только с частью регулярного выражения. Для этого используются круглые скобки:

Регулярное выражение: (John|Harold) Smith
Пример: Harold Smith went to meet John Smith but instead bumped into Jane Smith.


Опережающие и ретроспективные проверки

Опережающие и ретроспективные проверки работают в одном из двух режимов:

   позитивный — мы пытаемся найти что-то соответствующее;

   негативный — мы пытаемся найти что-то несоответствующее.

Главная идея как опережающей, так и ретроспективной проверок состоит в том, чтобы посмотреть, есть ли что-то соответствующее (или несоответствующее), а затем использовать или отбросить результат (то, что было найдено).


Опережающая проверка:

При опережающей проверке мы хотим заглянуть вперед (отсюда и название проверки) нашей строки и посмотреть, соответствует ли она заданному шаблону или нет. Если соответствие найдено, то мы его игнорируем и продолжаем поиск.

Например, допустим, что нам нужно идентифицировать числа больше 4000, но меньше 5000. Эта задачка выглядит на первый взгляд простой, но на самом деле она чуть сложнее. Обычно, первым решением, которое приходит на ум, является:

Регулярное выражение: \b4\d\d\d\b
Пример: This looks promising with 4021 but unfortunately also matches 4000.

Теперь мы понимаем, что нам нужно искать число 4, за которым следуют 3 цифры, и хотя бы одна из этих цифр не должна быть нулем. Мы можем попробовать сделать следующее:

Регулярное выражение: \b4([1-9]\d\d|\d[1-9]\d|\d\d[1-9])\b
Пример: Now we will match 4010 but not 4000.

Да, мы используем чередование с тремя разными сценариями, в каждом из которых последовательность состоит из 3 цифр, и хотя бы одна из этих трех цифр не должна быть нулем.

Теперь вы можете подумать, глядя на всё вышеизложенное, что регулярное выражение для всего лишь 4 цифр получилось слишком громоздким. И подумайте о том, как оно увеличится, если вместо диапазона от 4000 до 5000 нам нужно будет искать совпадения в диапазоне от 40000 до 50000. Вы быстро убедитесь, что вышеприведенное регулярное выражение работает, но оно не элегантно и не масштабируется.

Оказывается, что негативная опережающая проверка может решить такие проблемы довольно легко.

Синтаксис негативной опережающей проверки:

(?!x)

Наша негативная опережающая проверка заключена в скобки, и первыми двумя символами являются ?!, символ х мы заменяем на то, что НЕ хотим найти.

Таким образом, мы можем решить вышеприведенную задачу следующим образом:

Регулярное выражение: \b4(?!000)\d\d\d\b
Пример: Now we still match 4010 but not 4000.

Это может показаться немного запутанным, поэтому давайте разберемся детально:

   сначала мы ищем цифру 4;

   когда мы находим 4, негативная опережающая проверка возвращает true, если следующие 3 символа не являются 000;

   если проверка возвращает true, то мы игнорируем текущий экземпляр и продолжаем поиск дальше в соответствии с нашим регулярным выражением.

Говоря простым языком, расшифруем регулярное выражение, приведенное выше, как: «Мы ищем 4, за которым не следует 3 нуля, но следуют 3 другие цифры».

Позитивная опережающая проверка работает аналогично, но символы внутри нее должны совпадать с тем, что мы хотим найти.

Синтаксис позитивной опережающей проверки:

(?=x)

Всё, что нам нужно сделать — это заменить ! на =.


Ретроспективная проверка:

Ретроспективные проверки работают так же, как и опережающие проверки, но вместо того, чтобы смотреть вперед, а затем отбрасывать или использовать результат, мы смотрим назад и затем отбрасываем или используем результат. Подобно опережающим проверкам, ретроспективные проверки также могут быть как позитивными, так и негативными. Они используют аналогичный синтаксис, но с добавлением < после ?.

Синтаксис позитивной ретроспективной проверки:

(?<=x)

Синтаксис негативной ретроспективной проверки:

(?<!x)

Допустим, нам нужно найти экземпляры, соответствующие слову Smith, но только если это фамилия. Чтобы сделать это, мы указываем, что хотим проверить слово перед найденным значением Smith, и, если это слово начинается с заглавной буквы, мы будем считать Smith фамилией:

Регулярное выражение: (?<=[A-Z]\w* )Smith
Пример: Now we won't identify Smith Francis but we will identify Harold Smith.

Поначалу разобраться с опережающими и ретроспективными проверками может быть немного сложно, но это всего лишь дело практики.




Итак, мы имеем указатель, который постепенно перемещается по строке поиска. Как только он сталкивается с символом, который соответствует началу регулярного выражения, он останавливается. Теперь запускается второй указатель, который перемещается вперед от первого указателя, символ за символом, проверяя с каждым шагом, сохраняется ли соответствие шаблону или нет. Если мы доберемся до конца шаблона и сохранится соответствие, то мы нашли совпадение. Если на любом шаге происходит сбой, то второй указатель отбрасывается, а основной указатель продолжает движение по строке.

   . — соответствует любому символу;

   [ ] — совпадает с символом из диапазона, содержащемуся в квадратных скобках;

   [^] — соответствует символам, которые не входят в диапазон, содержащийся в квадратных скобках;

   * — совпадение 0 или более раз с указанным элементом;

   + — совпадение 1 или более раз с указанным элементом;

   ? — совпадение 0 или 1 раз с указанным элементом;

   {n} — точное совпадение n раз с указанным элементом;

   {n, m} — точное совпадение от n до m раз с указанным элементом;

   {n, } — точное совпадение n или более раз с указанным элементом;

   \ — экранирование или отмена специального значения указанного символа.

   \s — соответствует любому «пробельному» символу (например: пробел, символ табуляции, символ новой строки и т.д.);

   \S — соответствует любому символу, который не относится к «пробельным»;

   \d — соответствует любому символу, который является цифрой (0–9);

   \D — соответствует любому символу, который не является цифрой;

   \w — соответствует любому символу, который является строковым символом (A-Z, a-z, 0-9 и _);

   \W — соответствует любому символу, который не является строковым символом;

   \t — соответствует символу табуляции;

   \r — соответствует символу возврата каретки;

   \n — соответствует символу новой строки;

   ^ — якорь, который обозначает начало строки;

   $ — якорь, который обозначает конец строки;

   \b — соответствует началу или концу слова.

   \< — соответствует началу слова.

   \> — соответствует концу слова.
   
   () — группируем часть регулярного выражения;

   \1, \2 и т.д. — ссылаемся на соответствие, найденное группой ранее;

   | — оператор ИЛИ: ищем соответствие либо правому, либо левому операнду;

   (?=x) — позитивная опережающая проверка;

   (?!x) — негативная опережающая проверка;

   (?<=x) — позитивная ретроспективная проверка;

   (?<!x) — негативная ретроспективная проверка.